diff --git a/Tupfile b/Tupfile
index 156cdde..d7fe6fb 100644
--- a/Tupfile
+++ b/Tupfile
@@ -1,51 +1,77 @@
-include_rules
-
-client_objs += src/tup/vardict.o
-client_objs += src/tup/access_event/send_event.o
-client_objs += src/tup/flock/fcntl.o
-: $(client_objs) |> !ar |> libtup_client.a
-: src/tup/vardict.h |> !cp |> tup_client.h
-
-srcs = src/tup/*.o
-srcs += src/tup/access_event/*.o
-srcs += src/tup/monitor/*.o
-srcs += src/tup/flock/*.o
-srcs += src/tup/server/*.o
-ifeq (@(TUP_USE_SYSTEM_SQLITE),y)
-LDFLAGS += -lsqlite3
+tup.dorulesfile()
+
+client_objs = {}
+table.insert(client_objs, 'src/tup/vardict.o')
+table.insert(client_objs, 'src/tup/access_event/send_event.o')
+table.insert(client_objs, 'src/tup/flock/fcntl.o')
+
+bang_ar(client_objs, 'libtup_client.a')
+bang_cp('src/tup/vardict.h', 'tup_client.h')
+
+srcs = tup.glob('src/tup/*.o')
+table.insert(srcs, 'src/tup/access_event/*.o')
+table.insert(srcs, 'src/tup/monitor/*.o')
+table.insert(srcs, 'src/tup/flock/*.o')
+table.insert(srcs, 'src/tup/server/*.o')
+if tup.getconfig('TUP_USE_SYSTEM_SQLITE') == 'y'
+then
+	table.insert(LDFLAGS, '-lsqlite3')
 else
-srcs += src/sqlite3/*.o
-endif
-srcs += src/inih/*.o
-srcs += src/compat/*.o
-: $(srcs) |> !ar |> libtup.a
-
-ifeq (@(TUP_SUDO_SUID),y)
-suid = ; chown root:root tup; chmod u+s tup
-endif
-
-LDFLAGS += `pkg-config fuse --libs`
-: src/tup/tup/main.o libtup.a |> ^ LINK tup^ version=`git describe`; echo "const char *tup_version(void) {return \"$version\";}" | $(CC) -x c -c - -o tup-version.o $(CFLAGS) -Wno-missing-prototypes; $(CC) %f tup-version.o -o tup -lpthread $(LDFLAGS) $(suid) |> tup tup-version.o
-
-ifneq (@(TUP_MINGW),)
-: src/dllinject/*.omingw |> ^ MINGW32LINK %o^ @(TUP_MINGW)-gcc -shared %f -lws2_32 -lpsapi -lshlwapi -o %o |> tup-dllinject.dll
-
-mingwsrcs = src/tup/*.omingw
-mingwsrcs += src/tup/access_event/*.omingw
-mingwsrcs += src/tup/monitor/*.omingw
-mingwsrcs += src/tup/tup/*.omingw
-mingwsrcs += src/tup/flock/*.omingw
-mingwsrcs += src/tup/server/*.omingw
-mingwsrcs += src/inih/*.omingw
-mingwsrcs += src/sqlite3/*.omingw
-mingwsrcs += src/compat/*.omingw
-mingwsrcs += src/compat/win32/*.omingw
-MINGWLDFLAGS += -Wl,--wrap=open
-MINGWLDFLAGS += -Wl,--wrap=close
-MINGWLDFLAGS += -Wl,--wrap=tmpfile
-MINGWLDFLAGS += -Wl,--wrap=stat
-MINGWLDFLAGS += -Wl,--wrap=dup
-MINGWLDFLAGS += -Wl,--wrap=__mingw_vprintf
-MINGWLDFLAGS += -Wl,--wrap=__mingw_vfprintf
-: $(mingwsrcs) tup-dllinject.dll |> ^ MINGW32LINK tup.exe^ version=`git describe`; echo "const char *tup_version(void) {return \"$version\";}" | @(TUP_MINGW)-gcc -x c -c - -o tup-version.omingw; @(TUP_MINGW)-gcc %f tup-version.omingw $(MINGWLDFLAGS) -o tup.exe |> tup.exe tup-version.omingw
-endif
+	table.insert(srcs, 'src/sqlite3/*.o')
+end
+table.insert(srcs, 'src/inih/*.o')
+table.insert(srcs, 'src/compat/*.o')
+bang_ar(srcs, 'libtup.a')
+
+suid = ''
+if tup.getconfig('TUP_SUDO_SUID') == 'y'
+then
+	suid = '; chown root:root tup; chmod u+s tup'
+end
+
+table.insert(LDFLAGS, '`pkg-config fuse --libs`')
+table.insert(LDFLAGS, '`pkg-config lua5.2 --libs`')
+tup.definerule {
+	inputs = 'src/tup/tup/main.o libtup.a',
+	outputs = 'tup tup-version.o', 
+	print = 'LINK tup',
+	command = 'version=`git describe`; echo "const char *tup_version(void) {return \\\"$version\\\";}" | ' .. CC .. ' -x c -c - -o tup-version.o ' .. table.concat(CFLAGS, ' ') .. ' -Wno-missing-prototypes; ' .. CC .. ' %f tup-version.o -o tup -lpthread ' .. table.concat(LDFLAGS, ' ') .. ' ' .. suid
+}
+
+if tup.getconfig('TUP_MINGW') ~= ''
+then
+local inputs = table.concat(tup.glob('src/dllinject/*.omingw'), ' ')
+local output = 'tup-dllinject.dll'
+tup.definerule {
+	inputs = inputs,
+	outputs = output,
+	print = ' MINGW32LINK ' .. output,
+	command = tup.getconfig('TUP_MINGW') .. '-gcc -shared ' .. inputs .. ' -lws2_32 -lpsapi -lshlwapi -o ' .. output 
+}
+
+mingwsrcs = tup.glob('src/tup/*.omingw')
+table.insert(mingwsrcs, 'src/tup/access_event/*.omingw')
+table.insert(mingwsrcs, 'src/tup/monitor/*.omingw')
+table.insert(mingwsrcs, 'src/tup/tup/*.omingw')
+table.insert(mingwsrcs, 'src/tup/flock/*.omingw')
+table.insert(mingwsrcs, 'src/tup/server/*.omingw')
+table.insert(mingwsrcs, 'src/inih/*.omingw')
+table.insert(mingwsrcs, 'src/sqlite3/*.omingw')
+table.insert(mingwsrcs, 'src/compat/*.omingw')
+table.insert(mingwsrcs, 'src/compat/win32/*.omingw')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=open')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=close')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=tmpfile')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=stat')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=dup')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=__mingw_vprintf')
+table.insert(MINGWLDFLAGS, '-Wl,--wrap=__mingw_vfprintf')
+
+local inputs = table.concat(mingwsrcs, ' ') .. ' tup-dllinject.dll'
+tup.definerule {
+	inputs = inputs,
+	outputs = 'tup.exe tup-version.omingw',
+	print = 'MINGW32LINK tup.exe',
+	command = 'version=`git describe`; echo "const char *tup_version(void) {return "$version";}" | ' .. tup.getconfig('TUP_MINGW') .. '-gcc -x c -c - -o tup-version.omingw; ' .. tup.getconfig('TUP_MINGW') .. '-gcc ' .. inputs .. ' tup-version.omingw ' .. table.concat(MINGWLDFLAGS, ' ')  .. '-o tup.exe'
+}
+end
diff --git a/Tuprules.tup b/Tuprules.tup
index b27b88f..66da4ad 100644
--- a/Tuprules.tup
+++ b/Tuprules.tup
@@ -1,68 +1,156 @@
-.gitignore
+tup.creategitignore()
 
-CC = gcc
+if not CFLAGS then CFLAGS = {} end
+if not CFLAGS_SPECIFIC then CFLAGS_SPECIFIC = {} end
+if not LDFLAGS then LDFLAGS = {} end
+if not LDFLAGS_SPECIFIC then LDFLAGS_SPECIFIC = {} end
+if not MINGWCFLAGS then MINGWCFLAGS = {} end
+if not MINGWLDFLAGS then MINGWLDFLAGS = {} end
 
-ifeq (@(TUP_DEBUG),y)
-CFLAGS += -g
+-- Lua auxiliary definitions
+prepare_tup_table = function(input)
+	setmetatable(input, { 
+		__index = function(table, key) 
+			rawset(table, key, {})
+			return rawget(table, key) 
+		end 
+	})
+end
+for index, specific in ipairs({CFLAGS_SPECIFIC, LDFLAGS_SPECIFIC})
+do
+	prepare_tup_table(specific)
+end
+
+table_concat = function(first, second)
+	output = {}
+	for index, value in ipairs(first) do table.insert(output, value) end
+	for index, value in ipairs(second) do table.insert(output, value) end
+	return output
+end
+
+CC = 'gcc'
+
+if tup.getconfig('TUP_DEBUG') == 'y'
+then
+	table.insert(CFLAGS, '-g')
 else
-CFLAGS += -Os
-endif
-
-CFLAGS += -W
-CFLAGS += -Wall
-ifeq (@(TUP_WERROR),y)
-CFLAGS += -Werror
-endif
-CFLAGS += -Wbad-function-cast
-CFLAGS += -Wcast-align
-CFLAGS += -Wcast-qual
-CFLAGS += -Wchar-subscripts
-CFLAGS += -Wmissing-prototypes
-CFLAGS += -Wnested-externs
-CFLAGS += -Wpointer-arith
-CFLAGS += -Wredundant-decls
-CFLAGS += -Wshadow
-CFLAGS += -Wstrict-prototypes
-CFLAGS += -Wwrite-strings
-CFLAGS += -Wswitch-enum
-CFLAGS += -fno-common
-CFLAGS += -I$(TUP_CWD)/src
-
-ifeq (@(TUP_32_BIT),y)
-CFLAGS += -m32
-LDFLAGS += -m32
-endif
-
-export PKG_CONFIG_PATH
-CFLAGS += `pkg-config fuse --cflags`
-
-# Compatibility function prototypes and include path for wrapper functions
-MINGWCFLAGS += -include $(TUP_CWD)/src/compat/win32/mingw.h
-MINGWCFLAGS += -I$(TUP_CWD)/src/compat/win32
-
-# _GNU_SOURCE lets us use the %lli flag correctly
-MINGWCFLAGS += -D_GNU_SOURCE
-
-# No symlinks on windows
-MINGWCFLAGS += -D'S_ISLNK(a)=0'
-MINGWCFLAGS += -Dlstat=stat
-
-# No sig_atomic_t on windows
-MINGWCFLAGS += -Dsig_atomic_t=int
-
-# Use the same value as linux here. The logic is in src/compat/unlinkat.c
-MINGWCFLAGS += -DAT_REMOVEDIR=0x200
-
-!cc = |> ^ CC %f^ $(CC) -c %f -o %o $(CFLAGS) $(CFLAGS_%f) |> %B.o
-!ld = |> ^ LINK %o^ $(CC) %f -o %o $(LDFLAGS) $(LDFLAGS_%o) |>
-!ar = |> ^ AR %o^ ar crs %o %f |>
-!dot = |> ^ DOT %f^ dot -Efontname="Vernada, serif" -Nfontname="Vernada, serif" -Efontsize=10 -Nfontsize=10 -Tpng %f > %o |>
-!cp = |> ^ CP %f -> %o^ cp %f %o |>
-ifeq (@(TUP_MINGW),)
-!mingwcc = |> |>
+	table.insert(CFLAGS, '-Os')
+end
+
+table.insert(CFLAGS, '-Wall')
+table.insert(CFLAGS, '-Wall')
+if tup.getconfig('TUP_WERROR') == 'y'
+then
+	table.insert(CFLAGS, '-Werror')
+end
+table.insert(CFLAGS, '-Wbad-function-cast')
+table.insert(CFLAGS, '-Wcast-align')
+table.insert(CFLAGS, '-Wcast-qual')
+table.insert(CFLAGS, '-Wchar-subscripts')
+table.insert(CFLAGS, '-Wmissing-prototypes')
+table.insert(CFLAGS, '-Wnested-externs')
+table.insert(CFLAGS, '-Wpointer-arith')
+table.insert(CFLAGS, '-Wredundant-decls')
+table.insert(CFLAGS, '-Wshadow')
+table.insert(CFLAGS, '-Wstrict-prototypes')
+table.insert(CFLAGS, '-Wwrite-strings')
+table.insert(CFLAGS, '-Wswitch-enum')
+table.insert(CFLAGS, '-fno-common')
+table.insert(CFLAGS, '-I' .. tup.getcwd() .. '/src')
+
+if tup.getconfig('TUP_32_BIT') == 'y'
+then
+	table.insert(CFLAGS, '-m32')
+	table.insert(LDFLAGS, '-m32')
+end
+
+tup.export('PKG_CONFIG_PATH')
+table.insert(CFLAGS, '`pkg-config fuse --cflags`')
+table.insert(CFLAGS, '`pkg-config lua5.2 --cflags`')
+
+-- Compatibility function prototypes and include path for wrapper functions
+table.insert(MINGWCFLAGS, '-include $(TUP_CWD)/src/compat/win32/mingw.h')
+table.insert(MINGWCFLAGS, '-I$(TUP_CWD)/src/compat/win32')
+
+-- _GNU_SOURCE lets us use the %lli flag correctly
+table.insert(MINGWCFLAGS, '-D_GNU_SOURCE')
+
+-- No symlinks on windows
+table.insert(MINGWCFLAGS, '-D\'S_ISLNK(a)=0\'')
+table.insert(MINGWCFLAGS, '-Dlstat=stat')
+
+-- No sig_atomic_t on windows
+table.insert(MINGWCFLAGS, '-Dsig_atomic_t=int')
+
+-- Use the same value as linux here. The logic is in src/compat/unlinkat.c
+table.insert(MINGWCFLAGS, '-DAT_REMOVEDIR=0x200')
+
+bang_cc = function(input)
+	local output = string.gsub(input, '%.c', '') .. '.o'
+	tup.definerule {
+		inputs = input,
+		outputs = output,
+		command = CC .. ' -c ' .. input .. ' -o ' .. output .. 
+			' ' .. table.concat(CFLAGS, ' ') .. 
+			' ' .. table.concat(CFLAGS_SPECIFIC[input], ' '),
+		print = 'CC ' .. input
+	}
+end
+bang_ld = function(inputs, output)
+	local inputs = table.concat(inputs, ' ')
+	tup.definerule {
+		inputs = inputs,
+		outputs = output,
+		command = CC .. ' ' .. inputs .. ' -o ' .. output ..
+			' ' .. table.concat(LDFLAGS, ' ') ..
+			' ' .. table.concat(LDFLAGS_SPECIFIC[output], ' '),
+		print = 'LINK ' .. output
+	}
+end
+bang_ar = function(inputs, output)
+	inputs = table.concat(inputs, ' ')
+	tup.definerule {
+		inputs = inputs,
+		outputs = output,
+		command = 'ar crs ' .. output .. ' ' .. inputs,
+		print = 'AR ' .. output
+	}
+end
+bang_dot = function(input, output)
+	tup.definerule {
+		inputs = input,
+		outputs = output,
+		command = 'dot -Efontname="Vernada, serif" -Nfontname="Vernada, serif" -Efontsize=10 -Nfontsize=10 -Tpng ' .. input .. ' > ' .. output,
+		print = 'DOT ' .. input
+	}
+end
+bang_cp = function(input, output)
+	tup.definerule {
+		inputs = input,
+		outputs = output,
+		command = 'cp ' .. input .. ' ' .. output,
+		print = 'CP ' .. input .. ' -> ' .. output
+	}
+end
+
+if tup.getconfig('TUP_MINGW') == ''
+then
+	bang_mingwcc = function(input)
+	end
 else
-!mingwcc = |> ^ MINGW32CC %f^ @(TUP_MINGW)-gcc -c %f -o %o $(CFLAGS) $(CFLAGS_%f) $(MINGWCFLAGS) |> %B.omingw
-endif
+	bang_mingwcc = function(input)
+		local output = string.gsub(input, '%.c', '') .. '.omingw'
+		tup.definerule {
+			inputs = input,
+			outputs = output,
+			command = tup.getconfig('TUP_MINGW') .. '-gcc -c ' .. input .. ' -o ' .. output .. 
+				' ' .. table.concat(CFLAGS, ' ') ..
+				' ' .. table.concat(CFLAGS_SPECIFIC[input], ' ') ..
+				' ' .. table.concat(MINGWCFLAGS, ' '),
+			print = 'MINGW32CC ' .. input
+		}
+	end
+end
 
-TUP_MONITOR = null
-include @(TUP_PLATFORM).tup
+TUP_MONITOR = 'null'
+tup.dofile(tup.getconfig('TUP_PLATFORM') .. '.tup')
diff --git a/bootstrap.sh b/bootstrap.sh
index 6e99536..b2e888d 100755
--- a/bootstrap.sh
+++ b/bootstrap.sh
@@ -2,7 +2,9 @@
 CFLAGS="-g" ./build.sh
 
 if [ ! -d .tup ]; then
-	./build/tup init
+	#gdb --args ./build/tup init
+	valgrind --sim-hints=fuse-compatible ./build/tup init
 fi
-./build/tup upd
+#gdb --args ./build/tup upd
+valgrind --sim-hints=fuse-compatible ./build/tup upd
 echo "Build complete. If ./tup works, you can remove the 'build' directory."
diff --git a/build.sh b/build.sh
index b078309..1065d6d 100755
--- a/build.sh
+++ b/build.sh
@@ -2,8 +2,8 @@
 
 label=${TUP_LABEL:-bootstrap}
 os=`uname -s`
-plat_cflags="`pkg-config fuse --cflags`"
-plat_ldflags="`pkg-config fuse --libs`"
+plat_cflags="`pkg-config fuse --cflags` `pkg-config --cflags lua5.2`"
+plat_ldflags="`pkg-config fuse --libs` `pkg-config --libs lua5.2`"
 plat_files=""
 CC=gcc
 case "$os" in
diff --git a/docs/html/Tupfile b/docs/html/Tupfile
index 2c06fce..c12b918 100644
--- a/docs/html/Tupfile
+++ b/docs/html/Tupfile
@@ -1,34 +1,96 @@
-.gitignore
-ifeq (@(TUP_WWW),y)
-
-pages += index.html
-pages += getting_started.html
-pages += examples.html
-pages += manual.html
-pages += tips_and_tricks.html
-pages += make_vs_tup.html
-pages += tup_vs_mordor.html
-pages += license.html
-pages += support.html
-
-examples += ex_a_first_tupfile.html
-examples += ex_dependencies.html
-examples += ex_generated_header.html
-examples += ex_multiple_directories.html
-
-# Use the 'examples' sub-menu for the examples page.
-flags_examples += -x
-
-ifeq (@(TUP_WWW_ANALYTICS),y)
-flags += -a
-endif
-
-: |> ^ GEN %o^ ./gen_menu.sh $(pages) > %o |> menu.inc
-: |> ^ GEN %o^ ./gen_ex_header.sh $(examples) > %o |> examples.inc
-: examples.inc |> ^ GEN %o^ ./gen_menu.sh -x $(pages) > %o |> menu-examples.inc
-: |> ^ GEN %o^ ./gen_examples.sh $(examples) > %o |> examples.html
-: ../../tup.1 |> ^ man2html %o^ man2html %f > %o |> manual.html
-: foreach $(pages) | menu.inc menu-examples.inc |> ^ GEN %o^ ./gen_page.sh $(flags) $(flags_%B) %f > %o |> %f.gen
-: foreach $(examples) | menu-examples.inc |> ^ GEN %o^ ./gen_page.sh $(flags) -x %f > %o |> %f.gen
-
-endif
+prepare_tup_table = function(input)
+	setmetatable(input, { 
+		__index = function(table, key) 
+			rawset(table, key, {})
+			return rawget(table, key) 
+		end 
+	})
+end
+
+tup.creategitignore()
+
+pages = {}
+examples = {}
+flags = {}
+flags_specific = {}
+prepare_tup_table(flags_specific)
+
+if tup.getconfig('TUP_WWW') == 'y'
+then
+
+table.insert(pages, 'index.html')
+table.insert(pages, 'getting_started.html')
+table.insert(pages, 'examples.html')
+table.insert(pages, 'manual.html')
+table.insert(pages, 'tips_and_tricks.html')
+table.insert(pages, 'make_vs_tup.html')
+table.insert(pages, 'tup_vs_mordor.html')
+table.insert(pages, 'license.html')
+table.insert(pages, 'support.html')
+
+table.insert(examples, 'ex_a_first_tupfile.html')
+table.insert(examples, 'ex_dependencies.html')
+table.insert(examples, 'ex_generated_header.html')
+table.insert(examples, 'ex_multiple_directories.html')
+
+-- Use the 'examples' sub-menu for the examples page.
+table.insert(flags_specific['examples'], '-x')
+
+if tup.getconfig('TUP_WWW_ANALYTICS') == 'y'
+then
+	table.insert(flags, '-a')
+end
+
+tup.definerule { 
+	outputs = 'menu.inc',
+	print = 'GEN ' .. outputs,
+	command = './gen_menu.sh ' .. table.concat(pages, ' ') .. ' > ' .. outputs
+}
+tup.definerule { 
+	outputs = 'examples.inc',
+	print = 'GEN ' .. outputs,
+	command = './gen_ex_header.sh ' .. table.concat(examples, ' ') .. ' > ' .. outputs
+}
+tup.definerule { 
+	inputs = 'examples.inc',
+	outputs = 'menu-examples.inc',
+	print = 'GEN ' .. outputs,
+	command = './gen_menu.sh -x ' .. table.concat(pages, ' ') .. ' > ' .. outputs
+}
+tup.definerule { 
+	outputs = 'examples.html',
+	print = 'GEN ' .. outputs,
+	command = './gen_examples.sh ' .. table.concat(examples, ' ') .. ' > ' .. outputs
+}
+tup.definerule {
+	inputs = '../../tup.1',
+	outputs = 'manual.html',
+	print = 'man2html ' .. outputs,
+	command = 'man2html ' .. inputs .. ' > ' .. outputs
+}
+for index, page in ipairs(pages)
+do
+	print('%B is ' .. string.gsub(page, '%..*', ''))
+	tup.definerule {
+		inputs = page .. ' menu.inc menu-examples.inc',
+		outputs = page .. '.gen',
+		print = 'GEN ' .. outputs,
+		command = './gen_page.sh ' .. 
+			table.concat(flags, ' ') .. 
+			' ' .. table.concat(flags_specific[string.gsub(page, '%..*', '')], ' ') .. 
+			' ' .. page .. ' > ' .. outputs
+	}
+end
+for index, example in ipairs(examples)
+do
+	tup.definerule {
+		inputs = page .. ' menu-examples.inc',
+		outputs = page .. '.gen',
+		print = 'GEN ' .. outputs,
+		command = './gen_page.sh ' .. 
+			table.concat(flags, ' ') ..
+			' -x ' .. page .. ' > ' .. outputs
+	}
+end
+
+end
diff --git a/docs/html/pub/Tupfile b/docs/html/pub/Tupfile
index 57535db..b439dc0 100644
--- a/docs/html/pub/Tupfile
+++ b/docs/html/pub/Tupfile
@@ -1,7 +1,36 @@
-include_rules
-ifeq (@(TUP_WWW),y)
-: foreach ../make*.dat |> ^ PLOT %f^ ../../../test/make_v_tup/plot %f > %o |> %B.png
-: foreach ../tup_vs_eye*.dat |> ^ PLOT %f^ ../../../test/make_v_tup/plot %f Eye > %o |> %B.png
-: foreach ../*.dot |> !dot |> %B.png
-: foreach ../*.gen |> ^ CP %o^ cp %f %o |> %B
-endif
+tup.dorulesfile()
+if tup.getconfig('TUP_WWW') == 'y'
+then
+	for file in tup.glob('../make*.dat')
+	do
+		output = string.sub(file, '\\.dat', '') .. '.png'
+		tup.definerule {
+			inputs = file,
+			outputs = output,
+			command = '../../../test/make_v_tup/plot ' .. input .. ' > ' .. output,
+			print = 'PLOT ' .. input
+		}
+	end
+	for file in tup.glob('../tup_vs_eye*.dat')
+	do
+		output = string.sub(file, '\\.dat', '') .. '.png'
+		tup.definerule {
+			inputs = file,
+			outputs = output,
+			command = '../../../test/make_v_tup/plot ' .. input .. ' Eye > ' .. output,
+			print = 'PLOT ' .. input
+		}
+	end
+	for file in tup.glob('../*.dot') do bang_dot(input, string.sub(file, '\\.dot', '') .. '.png') end
+	for file in tup.glob('../*.gen')
+	do
+		output = string.sub(file, '\\.gen', '')
+		tup.definerule {
+			inputs = file,
+			outputs = output,
+			command = 'cp ' .. file .. ' ' .. output,
+			print = 'CP ' .. output
+		}
+	end
+end
+
diff --git a/freebsd.tup b/freebsd.tup
index de577c5..ea08b34 100644
--- a/freebsd.tup
+++ b/freebsd.tup
@@ -1 +1 @@
-CFLAGS += -include compat/freebsd.h
+table.insert(CFLAGS, '-include compat/freebsd.h')
diff --git a/linux.tup b/linux.tup
index e03fb85..0d60453 100644
--- a/linux.tup
+++ b/linux.tup
@@ -1 +1 @@
-TUP_MONITOR = inotify
+TUP_MONITOR = 'inotify'
diff --git a/macosx.tup b/macosx.tup
index 09b8285..58121e6 100644
--- a/macosx.tup
+++ b/macosx.tup
@@ -1,8 +1,8 @@
-# Build for the future as this is the direction Apple is moving to
-CC = clang
+-- Build for the future as this is the direction Apple is moving to
+CC = 'clang'
 
-CFLAGS += -DAT_SYMLINK_NOFOLLOW=0x100
-CFLAGS += -DAT_REMOVEDIR=0x200
+table.insert(CFLAGS, '-DAT_SYMLINK_NOFOLLOW=0x100')
+table.insert(CFLAGS, '-DAT_REMOVEDIR=0x200')
 
-# Implementation of *at() functions
-CFLAGS += -include compat/macosx.h
+-- Implementation of *at() functions
+table.insert(CFLAGS, '-include compat/macosx.h')
diff --git a/solaris.tup b/solaris.tup
index e433710..34647cd 100644
--- a/solaris.tup
+++ b/solaris.tup
@@ -1,4 +1,4 @@
 # _REENTRANT makes errno threadsafe. Otherwise things explode in an otherwise
 # not-so-informative fashion.
-CFLAGS += -D_REENTRANT
-LDFLAGS += -lsocket
+table.insert(CFLAGS, '-D_REENTRANT')
+table.insert(LDFLAGS, '-lsocket')
diff --git a/src/compat/Tupfile b/src/compat/Tupfile
index 0b1827a..b29f967 100644
--- a/src/compat/Tupfile
+++ b/src/compat/Tupfile
@@ -1,47 +1,54 @@
-include_rules
-
-# Changes here need to be reflected in the build.sh file
-ifeq (@(TUP_PLATFORM),linux)
-	srcs += utimensat_linux.c
-	srcs += dummy.c
-endif
-
-ifeq (@(TUP_PLATFORM),freebsd)
-	srcs += utimensat_linux.c
-	srcs += dummy.c
-	srcs += clearenv.c
-endif
-
-ifeq (@(TUP_PLATFORM),macosx)
-srcs += clearenv.c
-srcs += dir_mutex.c
-
-srcs += faccessat.c
-srcs += fchmodat.c
-srcs += fchownat.c
-srcs += fdopendir.c
-srcs += fstatat.c
-srcs += mkdirat.c
-srcs += openat.c
-srcs += readlinkat.c
-srcs += renameat.c
-srcs += symlinkat.c
-srcs += unlinkat.c
-srcs += utimensat.c
-
-endif
-
-ifeq (@(TUP_PLATFORM),solaris)
-srcs += dir_mutex.c
-srcs += mkdirat.c
-srcs += readlinkat.c
-endif
-: foreach $(srcs) |> !cc |>
-
-mingwsrcs += dir_mutex.c
-mingwsrcs += fstatat.c
-mingwsrcs += mkdirat.c
-mingwsrcs += openat.c
-mingwsrcs += renameat.c
-mingwsrcs += unlinkat.c
-: foreach $(mingwsrcs) |> !mingwcc |>
+tup.dorulesfile()
+
+-- Changes here need to be reflected in the build.sh file
+srcs = {}
+mingwsrcs = {}
+
+if tup.getconfig('TUP_PLATFORM') == 'linux'
+then
+	table.insert(srcs, 'utimensat_linux.c')
+	table.insert(srcs, 'dummy.c')
+end
+
+if tup.getconfig('TUP_PLATFORM') == 'freebsd'
+then
+	table.insert(srcs, 'utimensat_linux.c')
+	table.insert(srcs, 'dummy.c')
+	table.insert(srcs, 'clearenv.c')
+end
+
+if tup.getconfig('TUP_PLATFORM') == 'macosx'
+then
+table.insert(srcs, 'clearenv.c')
+table.insert(srcs, 'dir_mutex.c')
+
+table.insert(srcs, 'faccessat.c')
+table.insert(srcs, 'fchmodat.c')
+table.insert(srcs, 'fchownat.c')
+table.insert(srcs, 'fdopendir.c')
+table.insert(srcs, 'fstatat.c')
+table.insert(srcs, 'mkdirat.c')
+table.insert(srcs, 'openat.c')
+table.insert(srcs, 'readlinkat.c')
+table.insert(srcs, 'renameat.c')
+table.insert(srcs, 'symlinkat.c')
+table.insert(srcs, 'unlinkat.c')
+table.insert(srcs, 'utimensat.c')
+
+end
+
+if tup.getconfig('TUP_PLATFORM') == 'solaris'
+then
+table.insert(srcs, 'dir_mutex.c')
+table.insert(srcs, 'mkdirat.c')
+table.insert(srcs, 'readlinkat.c')
+end
+for index, file in ipairs(srcs) do bang_cc(file) end
+
+table.insert(mingwsrcs, 'dir_mutex.c')
+table.insert(mingwsrcs, 'fstatat.c')
+table.insert(mingwsrcs, 'mkdirat.c')
+table.insert(mingwsrcs, 'openat.c')
+table.insert(mingwsrcs, 'renameat.c')
+table.insert(mingwsrcs, 'unlinkat.c')
+for index, file in ipairs(srcs) do bang_mingwcc(file) end
diff --git a/src/compat/win32/Tupfile b/src/compat/win32/Tupfile
index 7b941f0..a5ad259 100644
--- a/src/compat/win32/Tupfile
+++ b/src/compat/win32/Tupfile
@@ -1,2 +1,2 @@
-include_rules
-: foreach *.c |> !mingwcc |>
+tup.dorulesfile()
+for index, file in ipairs(tup.glob('*.c')) do bang_mingwcc(file) end
diff --git a/src/dllinject/Tupfile b/src/dllinject/Tupfile
index 9805755..5f95cb1 100644
--- a/src/dllinject/Tupfile
+++ b/src/dllinject/Tupfile
@@ -1,4 +1,4 @@
-include_rules
-CFLAGS += -Wno-missing-prototypes
-CFLAGS += -DNDEBUG
-: foreach *.c |> !mingwcc |>
+tup.dorulesfile()
+table.insert(CFLAGS, '-Wno-missing-prototypes')
+table.insert(CFLAGS, '-DNDEBUG')
+for index, file in ipairs(tup.glob('*.c')) do bang_mingwcc(file) end
diff --git a/src/inih/Tupfile b/src/inih/Tupfile
index 60eca2d..ac1f302 100644
--- a/src/inih/Tupfile
+++ b/src/inih/Tupfile
@@ -1,10 +1,14 @@
-include_rules
+tup.dorulesfile()
 
-# Has some warnings about casting away const
-CFLAGS += -Wno-cast-qual
+-- Has some warnings about casting away const
+table.insert(CFLAGS, '-Wno-cast-qual')
 
-# Don't need multiline support - we just set some ints.
-CFLAGS += -DINI_ALLOW_MULTILINE=0
+-- Don't need multiline support - we just set some ints.
+table.insert(CFLAGS, '-DINI_ALLOW_MULTILINE=0')
+
+for index, file in ipairs(tup.glob('*.c'))
+do
+	bang_cc(file)
+	bang_mingwcc(file)
+end
 
-: foreach *.c |> !cc |>
-: foreach *.c |> !mingwcc |>
diff --git a/src/sqlite3/Tupfile b/src/sqlite3/Tupfile
index bd4d339..6d291ea 100644
--- a/src/sqlite3/Tupfile
+++ b/src/sqlite3/Tupfile
@@ -1,18 +1,19 @@
-include_rules
+tup.dorulesfile()
 
-# Remove warnings from CFLAGS
-CFLAGS += -w
+-- Remove warnings from CFLAGS
+table.insert(CFLAGS, '-w')
 
-# Use memory by default for temporary tables
-CFLAGS += -DSQLITE_TEMP_STORE=2
+-- Use memory by default for temporary tables
+table.insert(CFLAGS, '-DSQLITE_TEMP_STORE=2')
 
-# tup does its own locking of the database
-CFLAGS += -DSQLITE_THREADSAFE=0
+-- tup does its own locking of the database
+table.insert(CFLAGS, '-DSQLITE_THREADSAFE=0')
 
-# No need to depend on libdl here.
-CFLAGS += -DSQLITE_OMIT_LOAD_EXTENSION
+-- No need to depend on libdl here.
+table.insert(CFLAGS, '-DSQLITE_OMIT_LOAD_EXTENSION')
 
-ifneq (@(TUP_USE_SYSTEM_SQLITE),y)
-: foreach *.c |> !cc |>
-endif
-: foreach *.c |> !mingwcc |>
+if tup.getconfig('TUP_USE_SYSTEM_SQLITE') ~= 'y'
+then
+	for index, file in ipairs(tup.glob('*.c')) do bang_cc(file) end
+end
+for index, file in ipairs(tup.glob('*.c')) do bang_mingwcc(file) end
diff --git a/src/tup/Tupfile b/src/tup/Tupfile
index f53cc2a..30e0e8e 100644
--- a/src/tup/Tupfile
+++ b/src/tup/Tupfile
@@ -1,3 +1,6 @@
-include_rules
-: foreach *.c |> !cc |>
-: foreach *.c |> !mingwcc |>
+tup.dorulesfile()
+for index, file in ipairs(tup.glob('*.c'))
+do
+	bang_cc(file)
+	bang_mingwcc(file)
+end
diff --git a/src/tup/access_event/Tupfile b/src/tup/access_event/Tupfile
index 40d1250..85452dc 100644
--- a/src/tup/access_event/Tupfile
+++ b/src/tup/access_event/Tupfile
@@ -1,4 +1,4 @@
-include_rules
+tup.dorulesfile()
 
-: foreach send_event.c |> !cc |>
-: foreach send_udp.c |> !mingwcc |>
+bang_cc('send_event.c')
+bang_mingwcc('send_udp.c')
diff --git a/src/tup/flock/Tupfile b/src/tup/flock/Tupfile
index 143a5cb..961e544 100644
--- a/src/tup/flock/Tupfile
+++ b/src/tup/flock/Tupfile
@@ -1,4 +1,4 @@
-include_rules
+tup.dorulesfile()
 
-: foreach fcntl.c |> !cc |>
-: foreach lock_file.c |> !mingwcc |>
+bang_cc('fcntl.c')
+bang_mingwcc('lock_file.c')
diff --git a/src/tup/monitor/Tupfile b/src/tup/monitor/Tupfile
index 9b1dc30..2613c9a 100644
--- a/src/tup/monitor/Tupfile
+++ b/src/tup/monitor/Tupfile
@@ -1,4 +1,3 @@
-include_rules
-
-: $(TUP_MONITOR).c |> !cc |>
-: null.c |> !mingwcc |>
+tup.dorulesfile()
+bang_cc(TUP_MONITOR .. '.c')
+bang_mingwcc('null.c')
diff --git a/src/tup/parser.c b/src/tup/parser.c
index 169ecea..f19c0f4 100755
--- a/src/tup/parser.c
+++ b/src/tup/parser.c
@@ -45,6 +45,11 @@
 #include <errno.h>
 #include <ctype.h>
 #include <sys/stat.h>
+#include <lua.h>
+#include <lualib.h>
+#include <lauxlib.h>
+
+typedef lua_State * scriptdata;
 
 #define SYNTAX_ERROR -2
 #define CIRCULAR_DEPENDENCY_ERROR -3
@@ -88,10 +93,10 @@ TAILQ_HEAD(path_list_head, path_list);
 
 struct rule {
 	int foreach;
-	char *input_pattern;
-	char *output_pattern;
+	const char *input_pattern;
+	const char *output_pattern;
 	struct bin *bin;
-	char *command;
+	const char *command;
 	int command_len;
 	struct name_list inputs;
 	struct name_list order_only_inputs;
@@ -158,15 +163,31 @@ struct tupfile {
 	struct timespan ts;
 	char ign;
 	char circular_dep_error;
+	scriptdata sd;
 };
 
+struct tuplua_reader_data
+{
+	struct buf *b;
+	int read;
+};
+
+struct tuplua_glob_data
+{
+	lua_State *ls;
+	const char *directory;
+	int directory_size;
+	int count;
+};
+
+static int execute_script(struct buf *b, struct tupfile *tf, const char *name);
 static int parse_tupfile(struct tupfile *tf, struct buf *b, const char *filename);
 static int var_ifdef(struct tupfile *tf, const char *var);
 static int eval_eq(struct tupfile *tf, char *expr, char *eol);
 static int include_rules(struct tupfile *tf);
 static int run_script(struct tupfile *tf, char *cmdline, int lno,
 		      struct bin_head *bl);
-static int export(struct tupfile *tf, char *cmdline);
+static int export(struct tupfile *tf, const char *cmdline);
 static int gitignore(struct tupfile *tf);
 static int rm_existing_gitignore(struct tupfile *tf, struct tup_entry *tent);
 static int include_file(struct tupfile *tf, const char *file);
@@ -184,7 +205,7 @@ static void free_banglist(struct bang_list_head *head);
 static int split_input_pattern(struct tupfile *tf, char *p, char **o_input,
 			       char **o_cmd, int *o_cmdlen, char **o_output,
 			       char **o_bin, int *swapio);
-static int parse_input_pattern(struct tupfile *tf, char *input_pattern,
+static int parse_input_pattern(struct tupfile *tf, const char *input_pattern,
 			       struct name_list *inputs,
 			       struct name_list *order_only_inputs,
 			       struct bin_head *bl, int required);
@@ -233,6 +254,381 @@ static char *eval(struct tupfile *tf, const char *string, int allow_nodes);
 
 static int debug_run = 0;
 
+/* SCRIPTING LANGUAGE CODE START */
+static const char *tuplua_reader(struct lua_State *L, void *data, size_t *size)
+{
+	struct tuplua_reader_data *lrd = data;
+	if(lrd->read)
+	{
+		*size = 0;
+		return 0;
+	}
+
+	lrd->read = 1;
+	*size = lrd->b->len;
+	return lrd->b->s;
+}
+
+static void tuplua_register_function(struct lua_State *ls, const char *name, lua_CFunction function, void *data)
+{
+        lua_getglobal(ls, "tup");
+	lua_pushlightuserdata(ls, data);
+	lua_pushcclosure(ls, function, 1);
+	lua_setfield(ls, 1, name);
+	lua_setglobal(ls, "tup");
+}
+
+static int tuplua_function_include(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	const char *file = NULL;
+
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Must be passed a filename as an argument.");
+
+	file = lua_tostring(ls, -1);
+	if(include_file(tf, file) < 0)
+		return luaL_error(ls, "Failed to include file \"%s\".", file);
+	return 0;
+}
+
+static int tuplua_function_includerules(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	if(include_rules(tf) < 0)
+		return luaL_error(ls, "Failed to include rules file.");
+	return 0;
+}
+
+static int tuplua_function_definerule(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	struct rule r;
+	size_t command_len = 0;
+	struct bin_head bl; /* Not really used */
+	const char *empty_check = NULL;
+
+	if(!lua_istable(ls, -1))
+		return luaL_error(ls, "This function must be passed a table containing parameters");
+
+	r.input_pattern = "";
+	r.empty_input = 1;
+	lua_getfield(ls, 1, "inputs");
+	if (lua_isstring(ls, -1))
+	{
+		r.input_pattern = lua_tostring(ls, -1);
+		for (empty_check = r.input_pattern; *empty_check != '\0'; ++empty_check)
+		{
+			if ((*empty_check != ' ') && 
+				(*empty_check != '\t') && 
+				(*empty_check != '\r') && 
+				(*empty_check != '\n'))
+			{
+				r.empty_input = 0;
+				break;
+			}
+		}
+	}
+	else lua_pop(ls, 1);
+
+	lua_getfield(ls, 1, "outputs");
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Parameter \"outputs\" must be a space-separated list of output files.");
+	r.output_pattern = lua_tostring(ls, -1);
+
+	lua_getfield(ls, 1, "command");
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Parameter \"command\" must be a string containing command specification.");
+	r.command = lua_tolstring(ls, -1, &command_len);
+	if(command_len > (size_t)1 << (sizeof(r.command_len) * 8))
+		return luaL_error(ls, "Parameter \"command\" is too long.");
+	r.command_len = command_len;
+
+	r.line_number = 0;
+	r.output_nl = NULL;
+	r.foreach = 0;
+	r.bin = NULL;
+
+	LIST_INIT(&bl);
+
+	if(execute_rule(tf, &r, &bl) < 0)
+		return luaL_error(ls, "Failed to define rule.");
+
+	bin_list_del(&bl);
+
+	return 0;
+}
+
+static int tuplua_function_getcwd(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	int dir_size = 0;
+	char *dir = NULL;
+
+	lua_settop(ls, 0);
+
+	if(get_relative_dir(NULL, tf->tupid, tf->curtent->tnode.tupid, &dir_size) < 0) {
+		fprintf(tf->f, "tup internal error: Unable to find relative directory length from ID %lli -> %lli\n", tf->tupid, tf->curtent->tnode.tupid);
+		tup_db_print(tf->f, tf->tupid);
+		tup_db_print(tf->f, tf->curtent->tnode.tupid);
+		return luaL_error(ls, "Failed to get directory path length in getcwd.");
+	}
+
+	if(dir_size == 0) {
+		lua_pushstring(ls, "");
+		return 1;
+	}
+
+	dir = malloc(dir_size + 1);
+	if(get_relative_dir(dir, tf->tupid, tf->curtent->tnode.tupid, &dir_size) < 0) {
+		fprintf(tf->f, "tup internal error: Unable to find relative directory length from ID %lli -> %lli\n", tf->tupid, tf->curtent->tnode.tupid);
+		tup_db_print(tf->f, tf->tupid);
+		tup_db_print(tf->f, tf->curtent->tnode.tupid);
+		free(dir);
+		return luaL_error(ls, "Failed to get directory path in getcwd.");
+	}
+	dir[dir_size] = '\0';
+
+	lua_pushlstring(ls, dir, dir_size);
+	free(dir);
+	return 1;
+}
+
+static int tuplua_function_getconfig(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	const char *name = NULL;
+	size_t name_size = 0;
+	char *value = NULL;
+	char *value_as_argument = NULL; /* tup_db_get_var moves the pointer, so this is a throwaway */
+	int value_size = 0;
+	struct tup_entry *tent = NULL;
+
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Must be passed an config variable name as an argument.");
+	name = lua_tolstring(ls, -1, &name_size);
+	value_size = tup_db_get_varlen(tf->variant, name, name_size) + 1;
+	if(value_size < 0)
+		luaL_error(ls, "Failed to get config variable length.");
+	value = malloc(value_size);
+	value_as_argument = value;
+	
+	tent = tup_db_get_var(tf->variant, name, name_size, &value_as_argument);
+	if(!tent)
+		return luaL_error(ls, "Failed to get config variable.");
+	value[value_size - 1] = '\0';
+
+	if(tupid_tree_add_dup(&tf->input_root, tent->tnode.tupid) < 0)
+		return luaL_error(ls, "Failed to get config variable (add_dup).");
+	
+	lua_pushstring(ls, value);
+	free(value);
+
+	return 1;
+}
+
+static int tuplua_glob_callback(void *arg, struct tup_entry *tent)
+{
+	struct tuplua_glob_data *data = arg;
+	size_t fullpath_length = 0;
+	char *fullpath = NULL;
+	if(data->directory != NULL)
+	{
+		fullpath_length = data->directory_size + 1 + tent->name.len;
+		fullpath = malloc(fullpath_length);
+		strncpy(fullpath, data->directory, data->directory_size);
+		fullpath[data->directory_size] = PATH_SEP;
+		strncpy(fullpath + data->directory_size + 1, tent->name.s, tent->name.len);
+	}
+	else
+	{
+		fullpath_length = tent->name.len;
+		fullpath = tent->name.s;
+	}
+
+	lua_pushinteger(data->ls, data->count++);
+	lua_pushlstring(data->ls, fullpath, fullpath_length);
+	lua_settable(data->ls, -3);
+
+	if(data->directory != NULL)
+		free(fullpath);
+
+	return 0;
+}
+
+static int tuplua_function_glob(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	char *pattern = NULL;
+	size_t pattern_size = 0;
+	struct path_list_head plist;
+	struct path_list *pl, *tmp;
+	struct tuplua_glob_data tgd;
+	struct tup_entry *srctent = NULL;
+	struct tup_entry *dtent;
+
+	tgd.ls = ls;
+	tgd.count = 1; /* Lua numbering starts from 1 */
+	tgd.directory = NULL;
+	tgd.directory_size = 0;
+
+	lua_settop(ls, 1);
+
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Must be passed a glob pattern as an argument.");
+	
+	if (lua_tolstring(ls, -1, &pattern_size) == NULL)
+		return luaL_error(ls, "Lua error while trying to retrieve glob pattern.");
+	pattern = malloc(pattern_size + 1);
+	strncpy(pattern, lua_tostring(ls, -1), pattern_size);
+	pattern[pattern_size] = '\0';
+	lua_pop(ls, 1);
+
+	TAILQ_INIT(&plist);
+	if(get_path_list(tf, pattern, &plist, tf->tupid, NULL) < 0)
+	{
+		free(pattern);
+		return luaL_error(ls, "Failed to parse paths in glob pattern \"%s\".", pattern);
+	}
+
+	if(parse_dependent_tupfiles(&plist, tf, tf->g) < 0)
+	{
+		free(pattern);
+		return luaL_error(ls, "Failed to process glob directory for pattern \"%s\".", pattern);
+	}
+	
+	TAILQ_FOREACH(pl, &plist, list) {
+		if(pl->path != NULL) {
+			tgd.directory = pl->path;
+			tgd.directory_size = pl->pel->path - pl->path - 1;
+		}
+
+		lua_newtable(ls);
+		if(tup_entry_add(pl->dt, &dtent) < 0)
+		{
+			free(pattern);
+			return luaL_error(ls, "Failed to add tup entry when processing glob pattern \"%s\".", pattern);
+		}
+		if(dtent->type == TUP_NODE_GHOST)
+		{
+			free(pattern);
+			return luaL_error(ls, "Unable to generate wildcard for directory '%s' since it is a ghost.\n", pl->path);
+		}
+		if(tup_db_select_node_dir_glob(tuplua_glob_callback, &tgd, pl->dt, pl->pel->path, pl->pel->len, &tf->g->gen_delete_root) < 0)
+		{
+			free(pattern);
+			return luaL_error(ls, "Failed to glob for pattern \"%s\" in build(?) tree.", pattern);
+		}
+
+		if(variant_get_srctent(tf->variant, pl->dt, &srctent) < 0)
+		{
+			free(pattern);
+			return luaL_error(ls, "Failed to find src tup entry while processing pattern \"%s\".", pattern);
+		}
+		if(srctent) {
+			if(tup_db_select_node_dir_glob(build_name_list_cb, &tgd, srctent->tnode.tupid, pl->pel->path, pl->pel->len, &tf->g->gen_delete_root) < 0)
+			{
+				free(pattern);
+				return luaL_error(ls, "Failed to glob for pattern \"%s\" in source(?) tree.", pattern);
+			}
+		}
+	}
+	
+	TAILQ_FOREACH_SAFE(pl, &plist, list, tmp) {
+		del_pl(pl, &plist);
+	}
+
+	return 1;
+}
+
+static int tuplua_function_export(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	const char *name = NULL;
+
+	if(!lua_isstring(ls, -1))
+		return luaL_error(ls, "Must be passed an environment variable name as an argument.");
+
+	name = lua_tostring(ls, -1);
+
+	if(export(tf, name) < 0)
+		return luaL_error(ls, "Failed to export environment variable \"%s\".", name);
+
+	return 0;
+}
+
+static int tuplua_function_creategitignore(lua_State *ls)
+{
+	struct tupfile *tf = lua_touserdata(ls, lua_upvalueindex(1));
+	tf->ign = 1;
+	return 0;
+}
+
+static int execute_script(struct buf *b, struct tupfile *tf, const char *name)
+{
+	struct tuplua_reader_data lrd;
+	struct lua_State *ls = NULL;
+	
+	lrd.read = 0;
+	lrd.b = b;
+
+	if(!tf->sd)
+	{
+		ls = luaL_newstate();
+		tf->sd = ls;
+	
+		/* Register tup interaction functions in the "tup" table in Lua */	
+		lua_newtable(ls);
+		lua_setglobal(ls, "tup");
+		tuplua_register_function(ls, "dofile", tuplua_function_include, tf);
+		tuplua_register_function(ls, "dorulesfile", tuplua_function_includerules, tf);
+		tuplua_register_function(ls, "definerule", tuplua_function_definerule, tf);
+		tuplua_register_function(ls, "getcwd", tuplua_function_getcwd, tf);
+		tuplua_register_function(ls, "getconfig", tuplua_function_getconfig, tf);
+		tuplua_register_function(ls, "glob", tuplua_function_glob, tf);
+		tuplua_register_function(ls, "export", tuplua_function_export, tf);
+		tuplua_register_function(ls, "creategitignore", tuplua_function_creategitignore, tf);
+
+		/* Load some basic libraries.  File-access functions are avoided so that accesses
+		 * must go through the tup methods. Load the debug library so tracebacks 
+		 * for errors can be formatted nicely */
+		lua_pushcfunction(ls, luaopen_base); lua_pushstring(ls, ""); lua_call(ls, 1, 0);
+		lua_pushcfunction(ls, luaopen_table); lua_pushstring(ls, LUA_TABLIBNAME); lua_call(ls, 1, 0);
+		lua_pushcfunction(ls, luaopen_string); lua_pushstring(ls, LUA_STRLIBNAME); lua_call(ls, 1, 0);
+		lua_pushcfunction(ls, luaopen_bit32); lua_pushstring(ls, LUA_BITLIBNAME); lua_call(ls, 1, 0);
+		lua_pushcfunction(ls, luaopen_math); lua_pushstring(ls, LUA_MATHLIBNAME); lua_call(ls, 1, 0);
+		lua_pushcfunction(ls, luaopen_debug); lua_pushstring(ls, LUA_DBLIBNAME); lua_call(ls, 1, 0);
+		lua_pushnil(ls); lua_setglobal(ls, "dofile");
+		lua_pushnil(ls); lua_setglobal(ls, "loadfile");
+		lua_pushnil(ls); lua_setglobal(ls, "load");
+		lua_pushnil(ls); lua_setglobal(ls, "require");
+		lua_pushnil(ls); lua_setglobal(ls, "loadfile");
+		lua_pushnil(ls); lua_setglobal(ls, "loadfile");
+
+		luaL_openlibs(ls);
+	}
+	else ls = tf->sd;
+
+	lua_getglobal(ls, "debug");
+	lua_getfield(ls, -1, "traceback");
+	lua_remove(ls, -2);
+
+	if(lua_load(ls, &tuplua_reader, &lrd, name, 0) != LUA_OK)
+	{
+		fprintf(tf->f, "tup error: Failed to open Tupfile:\n%s\n", lua_tostring(ls, -1));
+		return 0;
+	}
+
+	if(lua_pcall(ls, 0, LUA_MULTRET, 1) != LUA_OK)
+	{
+		fprintf(tf->f, "tup error: Failed to execute Tupfile:\n%s\n", lua_tostring(ls, -1));
+		return 0;
+	}
+
+	return 1;
+}
+/* SCRIPTING LANGUAGE CODE STOP */
+
 void parser_debug_run(void)
 {
 	debug_run = 1;
@@ -264,6 +660,7 @@ int parse(struct node *n, struct graph *g, struct timespan *retts)
 		perror("tmpfile");
 		return -1;
 	}
+	tf.sd = NULL;
 
 	init_file_info(&ps.s.finfo, tf.variant->variant_dir);
 	ps.s.id = n->tnode.tupid;
@@ -329,8 +726,10 @@ int parse(struct node *n, struct graph *g, struct timespan *retts)
 
 	if(fslurp_null(fd, &b) < 0)
 		goto out_close_file;
-	if(parse_tupfile(&tf, &b, "Tupfile") < 0)
+	if(!execute_script(&b, &tf, "Tupfile"))
 		goto out_free_bs;
+	/*if(parse_tupfile(&tf, &b, "Tupfile") < 0)
+		goto out_free_bs;*/
 	if(tf.ign) {
 		if(rm_existing_gitignore(&tf, n->tent) < 0)
 			return -1;
@@ -780,7 +1179,7 @@ out_err:
 	return -1;
 }
 
-static int export(struct tupfile *tf, char *cmdline)
+static int export(struct tupfile *tf, const char *cmdline)
 {
 	struct tup_entry *tent = NULL;
 
@@ -940,8 +1339,10 @@ static int include_file(struct tupfile *tf, const char *file)
 	if(fslurp_null(fd, &incb) < 0)
 		goto out_close;
 
-	if(parse_tupfile(tf, &incb, file) < 0)
+	if(!execute_script(&incb, tf, file))
 		goto out_free;
+	/*if(parse_tupfile(tf, &incb, file) < 0)
+		goto out_free;*/
 	rc = 0;
 out_free:
 	free(incb.s);
@@ -1646,7 +2047,7 @@ static int split_input_pattern(struct tupfile *tf, char *p, char **o_input,
 	return 0;
 }
 
-static int parse_input_pattern(struct tupfile *tf, char *input_pattern,
+static int parse_input_pattern(struct tupfile *tf, const char *input_pattern,
 			       struct name_list *inputs,
 			       struct name_list *order_only_inputs,
 			       struct bin_head *bl, int required)
@@ -1693,7 +2094,7 @@ static int execute_rule(struct tupfile *tf, struct rule *r, struct bin_head *bl)
 {
 	struct name_list output_nl;
 	struct name_list_entry *nle;
-	char *last_output_pattern;
+	const char *last_output_pattern;
 	char empty_pattern[] = "";
 
 	init_name_list(&r->inputs);
@@ -1829,8 +2230,8 @@ static int execute_rule_internal(struct tupfile *tf, struct rule *r,
 	if(foreach) {
 		struct name_list tmp_nl;
 		struct name_list_entry tmp_nle;
-		char *old_command = NULL;
-		char *old_output_pattern = NULL;
+		const char *old_command = NULL;
+		const char *old_output_pattern = NULL;
 		int old_command_len = 0;
 
 		/* For a foreach loop, iterate over each entry in the rule's
diff --git a/src/tup/server/Tupfile b/src/tup/server/Tupfile
index 9594a4f..dac375c 100644
--- a/src/tup/server/Tupfile
+++ b/src/tup/server/Tupfile
@@ -1,3 +1,3 @@
-include_rules
-: foreach fuse_server.c fuse_fs.c master_fork.c |> !cc |>
-: windepfile.c |> !mingwcc |>
+tup.dorulesfile()
+for index, file in ipairs({'fuse_server.c', 'fuse_fs.c', 'master_fork.c'}) do bang_cc(file) end
+bang_mingwcc('windepfile.c')
diff --git a/src/tup/tup/Tupfile b/src/tup/tup/Tupfile
index f53cc2a..052070d 100644
--- a/src/tup/tup/Tupfile
+++ b/src/tup/tup/Tupfile
@@ -1,3 +1,3 @@
-include_rules
-: foreach *.c |> !cc |>
-: foreach *.c |> !mingwcc |>
+tup.dorulesfile()
+for index, file in ipairs(tup.glob('*.c')) do bang_cc(file) end
+for index, file in ipairs(tup.glob('*.c')) do bang_mingwcc(file) end
